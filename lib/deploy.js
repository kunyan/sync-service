const fsp = require("fs").promises;
const path = require("path");
const decompress = require("decompress");
const config = require("../config");
const mvdir = require("mvdir");
const tmp = require("tmp-promise");
const { last } = require("lodash");
const replace = require("replace-in-file");
const common = require("@spaship/common");
const metadata = require("./metadata");
const Autosync = require("./background/autosync");

async function deploy({ name, spaArchive, appPath, ref } = {}) {
  // create a dir in the tmp_dir location, but keep the random archive name
  let tmpDir = `${spaArchive}-extracted`;
  await fsp.mkdir(tmpDir);
  // const tmpDir = await fsp.m({ template: path.join(config.get("tmp_dir"), " });

  // extract the archive
  await decompress(spaArchive, tmpDir);

  // detect if the archive was created with `npm pack`.  npm pack creates a
  // tarball with a "package" dir.  we want what's in the package dir but not
  // the dir itself.
  let isNpmPack;
  try {
    const packageStat = await fsp.lstat(path.join(tmpDir, "package"));
    isNpmPack = packageStat.isDirectory();
  } catch (e) {
    isNpmPack = false;
  }

  // if the archive was generated by `npm pack`, move into the "package"
  // directory where all the goodies are.
  if (isNpmPack) {
    tmpDir = path.join(tmpDir, "package");
  }

  let spaConfig = { name, path: appPath };
  let hasYaml = false;
  let incomingDeployKey;
  const yamlFilePath = path.join(tmpDir, "spaship.yaml");
  try {
    spaConfig = await common.config.read(yamlFilePath);
    incomingDeployKey = spaConfig.deploykey;
    hasYaml = true;
  } catch (e) {}

  const validation = common.config.validate(spaConfig);

  if (!validation.valid) {
    throw new Error(
      `spaship.yaml is not valid: ${JSON.stringify(validation.errors)}`
    );
  }

  // remove starting slashes in paths
  const flatPath = common.flatpath.toDir(spaConfig.path);
  const destDir = path.join(config.get("webroot"), flatPath);

  // write spa metadata to filesystem
  if (!hasYaml) {
    metadata.write(path.join(tmpDir, "spaship.yaml"), {
      name,
      path: spaConfig.path
    });
  }
  if (ref) {
    metadata.write(path.join(tmpDir, "spaship.yaml"), {
      ref
    });
  }

  let existingDeployKey;
  try {
    const existingConfig = await common.config.read(
      path.join(destDir, "spaship.yaml")
    );
    existingDeployKey = existingConfig.deploykey;
  } catch (e) {}

  const firstDeploy = typeof existingDeployKey === "undefined";

  // if the deployment doesn't have a deploykey, add one
  if (firstDeploy && !incomingDeployKey) {
    const deploykey = common.config.deploykey.generate();
    metadata.write(yamlFilePath, {
      deploykey
    });
  }

  // write htaccess file
  await common.htaccess.write(tmpDir, spaConfig);

  // if single
  //  in index.html, replace SPASHIP_INCLUDE(.*) with the named contents
  // else
  //  in all html files, replace SPASHIP_INCLUDE(.*) with the named contents
  let incFiles;
  if (spaConfig.single) {
    incFiles = path.join(tmpDir, "index.html");
  } else {
    incFiles = path.join(tmpDir, "**/*.html");
  }
  const replaceCounts = {};
  const replaceOptions = {
    countMatches: true,
    // dry: true,
    files: incFiles,
    from: /<!--\s*SPASHIP_INCLUDE\(([A-Za-z0-9_-]+)\)\s*-->/g,
    to: (...args) => {
      // TODO resume here, replace SPASHIP_INCLUDE comments with SSI comments
      console.log(args);
      const filename = last(args);
      replaceCounts[filename] = ~~replaceCounts[filename] + 1;
      console.log(
        `replacement number ${replaceCounts[filename]} in ${filename}`
      );

      const ssi = [];
      const targetName = args[1];
      console.log(`injecting ${targetName}`);
      // include init SSI tag if this is the first replacement in this file
      if (replaceCounts[filename] === 1) {
        ssi.push(`<!--#include virtual="/init.html" -->`);
      }
      ssi.push(`<!--#include virtual="${targetName}" -->`);
      return ssi.join("\n");
    }
  };

  const results = await replace(replaceOptions);

  // deploy if:
  //   no existing deploy key, or
  //   existing deploy key and incoming key matches
  const deployKeysValid =
    typeof existingDeployKey === "string" &&
    typeof incomingDeployKey === "string";
  const deployKeysMatch = existingDeployKey === incomingDeployKey;

  if (firstDeploy || (deployKeysValid && deployKeysMatch)) {
    await mvdir(tmpDir, destDir);
  } else {
    throw new Error("refusing to deploy; deploykey does not match");
  }

  console.log(`[deploy] deployed "${spaConfig.name}" to ${destDir}`);
}

module.exports = deploy;
